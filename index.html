<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mahjong Solitaire</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React / ReactDOM (CDN UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Framer Motion UMD -->
  <script src="https://unpkg.com/framer-motion/dist/framer-motion.umd.js"></script>
  <style>
    html, body, #root { height: 100%; }
    body { background: #f8fafc; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;
    const { motion, AnimatePresence } = window.framerMotion;

    // ---- Config ----
    const TILE_W = 80;
    const TILE_H = 100;
    const GRID_UNIT_W = TILE_W * 0.5;
    const GRID_UNIT_H = TILE_H * 0.5;

    // ---- Utilities ----
    const shuffle = (arr) => {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    };

    const useBeep = () => {
      const ctxRef = useRef(null);
      const ensure = () => {
        if (!ctxRef.current && typeof window !== "undefined") {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) ctxRef.current = new AC();
        }
        return ctxRef.current;
      };
      const beep = (freq = 660, ms = 80, type = "sine", gain = 0.02) => {
        const ctx = ensure();
        if (!ctx) return;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g);
        g.connect(ctx.destination);
        const t = ctx.currentTime;
        o.start(t);
        o.stop(t + ms / 1000);
      };
      return beep;
    };

    // Emoji faces for tiles (pairs)
    const FACE_POOL = [
      "ðŸ€„","ðŸ‰","ðŸ€«","ðŸ€©","ðŸ€°","ðŸ€™","ðŸ€š","ðŸ€›","ðŸ€œ","ðŸ€",
      "â™£ï¸","â™¦ï¸","â™¥ï¸","â™ ï¸","ðŸŒ¸","ðŸ€","ðŸ","ðŸŒ¼","ðŸ’®","â­",
      "ðŸ‰","ðŸ¢","ðŸª·","ðŸ‚","ðŸŒ™","â˜€ï¸","ðŸ”¥","ðŸ’§","ðŸŒªï¸","ðŸªµ",
      "1","2","3","4","5","6","7","8","9"
    ];

    const makeFaces = (pairCount) => {
      const pool = [...FACE_POOL];
      while (pool.length < pairCount) pool.push(...FACE_POOL);
      const faces = shuffle(pool).slice(0, pairCount);
      return shuffle(
        faces.flatMap((f, i) => [{ face: f, key: `${f}-${i}-a` }, { face: f, key: `${f}-${i}-b` }])
      );
    };

    // Classic-ish turtle layout
    const buildTurtleLayout = () => {
      const layers = [
        { w: 15, h: 7 },
        { w: 13, h: 5 },
        { w: 11, h: 3 },
        { w: 9,  h: 3 },
        { w: 1,  h: 1 },
      ];
      const coords = [];
      layers.forEach((L, z) => {
        for (let y = -(L.h - 1); y <= (L.h - 1); y += 2) {
          for (let x = -(L.w - 1); x <= (L.w - 1); x += 2) {
            coords.push({ x, y, z });
          }
        }
      });
      // shoulders on base layer
      const shoulderZ = 0;
      for (let y = -1; y <= 1; y += 2) {
        for (let x = -19; x <= -17; x += 2) coords.push({ x, y, z: shoulderZ });
        for (let x = 17; x <= 19; x += 2) coords.push({ x, y, z: shoulderZ });
      }
      return coords;
    };

    const toPixel = (pos, center) => {
      const { x, y, z } = pos;
      return {
        left: center.x + x * GRID_UNIT_W - TILE_W / 2 + z * 2,
        top:  center.y + y * GRID_UNIT_H - TILE_H / 2 - z * 2,
        zIndex: 100 + z,
      };
    };

    const isOverlappingTop = (tile, allTiles) => {
      if (tile.removed) return false;
      const rect = { x: tile.x, y: tile.y, z: tile.z };
      return allTiles.some(
        (t) => !t.removed && t.z === rect.z + 1 &&
               Math.abs(t.x - rect.x) <= 2 &&
               Math.abs(t.y - rect.y) <= 2
      );
    };

    const isSideBlocked = (tile, allTiles) => {
      const leftBlocked  = allTiles.some((t) => !t.removed && t.z === tile.z && t.y === tile.y && t.x === tile.x - 2);
      const rightBlocked = allTiles.some((t) => !t.removed && t.z === tile.z && t.y === tile.y && t.x === tile.x + 2);
      return { leftBlocked, rightBlocked };
    };

    const isFree = (tile, allTiles) => {
      if (tile.removed) return false;
      if (isOverlappingTop(tile, allTiles)) return false;
      const { leftBlocked, rightBlocked } = isSideBlocked(tile, allTiles);
      return !(leftBlocked && rightBlocked);
    };

    // ---- Main Component ----
    function MahjongSolitaire() {
      const containerRef = useRef(null);
      const [boardSize, setBoardSize] = useState({ w: 1000, h: 700 });
      const [theme, setTheme] = useState("emerald");
      const [soundOn, setSoundOn] = useState(true);
      const beep = useBeep();

      const layout = useMemo(() => buildTurtleLayout(), []);
      const pairCount = Math.floor(layout.length / 2);

      const [tiles, setTiles] = useState(() => {
        const faces = makeFaces(pairCount);
        const positions = shuffle(layout).slice(0, faces.length);
        return faces.map((f, i) => ({
          id: i,
          face: f.face,
          key: f.key,
          removed: false,
          x: positions[i].x,
          y: positions[i].y,
          z: positions[i].z,
        }));
      });

      const [selectedIds, setSelectedIds] = useState([]);
      const [moves, setMoves] = useState(0);
      const [startTs] = useState(() => Date.now());
      const [elapsed, setElapsed] = useState(0);
      const [history, setHistory] = useState([]);
      const [message, setMessage] = useState("Match any free pair to start!");

      // responsive board
      useEffect(() => {
        const onResize = () => {
          const el = containerRef.current;
          if (!el) return;
          const rect = el.getBoundingClientRect();
          setBoardSize({ w: rect.width, h: rect.height });
        };
        onResize();
        window.addEventListener("resize", onResize);
        return () => window.removeEventListener("resize", onResize);
      }, []);

      // timer
      useEffect(() => {
        const t = setInterval(() => setElapsed(Date.now() - startTs), 1000);
        return () => clearInterval(t);
      }, [startTs]);

      const center = { x: boardSize.w / 2, y: boardSize.h / 2 };

      const freeSet = useMemo(() => {
        const set = new Set();
        tiles.forEach((t) => { if (!t.removed && isFree(t, tiles)) set.add(t.id); });
        return set;
      }, [tiles]);

      const remainingPairs = useMemo(() => {
        const alive = tiles.filter((t) => !t.removed);
        return Math.floor(alive.length / 2);
      }, [tiles]);

      const fmtTime = (ms) => {
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${m.toString().padStart(2, "0")}:${r.toString().padStart(2, "0")}`;
      };

      const clickTile = (id) => {
        const t = tiles.find((x) => x.id === id);
        if (!t || t.removed) return;
        if (!freeSet.has(id)) {
          setMessage("That tile is blocked.");
          if (soundOn) beep(160, 70, "square", 0.01);
          return;
        }
        if (soundOn) beep(480, 80, "triangle", 0.01);
        setSelectedIds((sel) => {
          if (sel.includes(id)) return sel.filter((x) => x !== id);
          const next = [...sel, id].slice(-2);
          if (next.length === 2) {
            const a = tiles.find((t) => t.id === next[0]);
            const b = tiles.find((t) => t.id === next[1]);
            if (a.face === b.face) {
              const snapshotA = { ...a };
              const snapshotB = { ...b };
              setTiles((old) => old.map((t) => (t.id === a.id || t.id === b.id ? { ...t, removed: true } : t)));
              setHistory((h) => [...h, [snapshotA, snapshotB]]);
              setMoves((m) => m + 1);
              setMessage("Nice match!");
              if (soundOn) beep(760, 100, "sine", 0.02);
              return [];
            } else {
              setMessage("Faces don't match.");
              if (soundOn) beep(120, 90, "sawtooth", 0.01);
            }
          }
          return next;
        });
      };

      const doHint = () => {
        const freeTiles = tiles.filter((t) => !t.removed && freeSet.has(t.id));
        for (let i = 0; i < freeTiles.length; i++) {
          for (let j = i + 1; j < freeTiles.length; j++) {
            if (freeTiles[i].face === freeTiles[j].face) {
              setSelectedIds([freeTiles[i].id, freeTiles[j].id]);
              setMessage("Hint: highlighted a possible pair.");
              return true;
            }
          }
        }
        setMessage("No free pairs. Try Shuffle.");
        return false;
      };

      const canUndo = history.length > 0;
      const doUndo = () => {
        if (!canUndo) return;
        const last = history[history.length - 1];
        setHistory((h) => h.slice(0, -1));
        setTiles((old) => {
          const map = new Map(old.map((t) => [t.id, t]));
          last.forEach((snap) => {
            map.set(snap.id, { ...snap, removed: false });
          });
          return Array.from(map.values());
        });
        setMoves((m) => Math.max(0, m - 1));
        setMessage("Undid last match.");
      };

      const checkAnyMoves = (arr) => {
        const free = arr.filter((t) => !t.removed && isFree(t, arr));
        for (let i = 0; i < free.length; i++) {
          for (let j = i + 1; j < free.length; j++) {
            if (free[i].face === free[j].face) return true;
          }
        }
        return false;
      };

      const doShuffle = () => {
        const alive = tiles.filter((t) => !t.removed);
        const dead = tiles.filter((t) => t.removed);
        let faces = shuffle(alive.map((t) => t.face));
        let attempts = 80;
        let rebuilt = null;
        while (attempts-- > 0) {
          const candidate = alive.map((t, i) => ({ ...t, face: faces[i] }));
          if (checkAnyMoves(candidate)) { rebuilt = candidate; break; }
          faces = shuffle(faces);
        }
        if (!rebuilt) rebuilt = alive.map((t, i) => ({ ...t, face: faces[i] }));
        const merged = [...rebuilt, ...dead];
        setTiles(merged);
        setSelectedIds([]);
        setMessage("Shuffled remaining tiles.");
        if (soundOn) beep(300, 90, "triangle", 0.015);
      };

      const doRestart = () => {
        const faces = makeFaces(pairCount);
        const positions = shuffle(layout).slice(0, faces.length);
        const fresh = faces.map((f, i) => ({
          id: i, face: f.face, key: f.key, removed: false,
          x: positions[i].x, y: positions[i].y, z: positions[i].z
        }));
        setTiles(fresh);
        setSelectedIds([]);
        setMoves(0);
        setMessage("New game! Match all pairs.");
      };

      const gameWon = tiles.every((t) => t.removed);

      // shortcuts
      useEffect(() => {
        const onKey = (e) => {
          if (e.key === "h") doHint();
          if (e.key === "u") doUndo();
          if (e.key === "r") doRestart();
          if (e.key === "s") doShuffle();
          if (e.key === "t") setTheme((th) => (th === "emerald" ? "rose" : th === "rose" ? "sky" : "emerald"));
        };
        window.addEventListener("keydown", onKey);
        return () => window.removeEventListener("keydown", onKey);
      }, [tiles]);

      const themeClasses = {
        emerald: {
          bg: "bg-emerald-50",
          panel: "bg-white/70 backdrop-blur",
          tile: "from-emerald-100 to-emerald-50 border-emerald-300",
          face: "text-emerald-900",
          accent: "text-emerald-700",
          btn: "bg-emerald-600 hover:bg-emerald-700 text-white",
        },
        rose: {
          bg: "bg-rose-50",
          panel: "bg-white/70 backdrop-blur",
          tile: "from-rose-100 to-rose-50 border-rose-300",
          face: "text-rose-900",
          accent: "text-rose-700",
          btn: "bg-rose-600 hover:bg-rose-700 text-white",
        },
        sky: {
          bg: "bg-sky-50",
          panel: "bg-white/70 backdrop-blur",
          tile: "from-sky-100 to-sky-50 border-sky-300",
          face: "text-sky-900",
          accent: "text-sky-700",
          btn: "bg-sky-600 hover:bg-sky-700 text-white",
        },
      }[theme];

      const Tile = ({ t }) => {
        const free = freeSet.has(t.id);
        const selected = selectedIds.includes(t.id);
        const pos = toPixel({ x: t.x, y: t.y, z: t.z }, center);
        return (
          <AnimatePresence>
            {!t.removed && (
              <motion.button
                key={t.id}
                initial={{ opacity: 0, y: -6 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.85, transition: { duration: 0.2 } }}
                whileHover={{ y: free ? -3 : 0 }}
                onClick={() => clickTile(t.id)}
                className={`absolute rounded-2xl shadow-lg border ${themeClasses.tile} bg-gradient-to-br ${
                  free ? "ring-2 ring-offset-2 ring-black/10" : "opacity-80"
                } ${selected ? "outline outline-4 outline-yellow-400" : ""}`}
                style={{ left: pos.left, top: pos.top, width: 80, height: 100, zIndex: pos.zIndex }}
                aria-label={`Tile ${t.face} ${free ? "free" : "blocked"}`}
              >
                <div className={`w-full h-full flex flex-col items-center justify-center select-none ${themeClasses.face}`}>
                  <div className="text-3xl leading-none">{t.face}</div>
                  <div className="text-[10px] opacity-60 mt-1">{free ? "free" : "blocked"}</div>
                </div>
                <div className="absolute -bottom-1 left-0 right-0 h-1 bg-black/10 rounded-b-2xl" />
                <div className="absolute -right-1 top-0 bottom-0 w-1 bg-black/10 rounded-r-2xl" />
              </motion.button>
            )}
          </AnimatePresence>
        );
      };

      return (
        <div className={`min-h-screen ${themeClasses.bg} text-slate-800`}>
          <div className="max-w-6xl mx-auto p-4">
            <header className="flex flex-wrap items-center justify-between gap-3">
              <div className="flex items-center gap-3">
                <div className="text-2xl font-bold">Mahjong Solitaire</div>
                <span className={`px-2 py-1 text-xs rounded-full ${themeClasses.panel} ${themeClasses.accent} border border-black/5`}>
                  Theme: {theme}
                </span>
              </div>
              <div className="flex flex-wrap gap-2">
                <button className={`px-3 py-2 rounded-xl shadow ${themeClasses.btn}`} onClick={doRestart}>New Game (R)</button>
                <button className={`px-3 py-2 rounded-xl shadow ${themeClasses.btn}`} onClick={doShuffle}>Shuffle (S)</button>
                <button className={`px-3 py-2 rounded-xl shadow ${themeClasses.btn}`} onClick={doHint}>Hint (H)</button>
                <button disabled={!canUndo} className={`px-3 py-2 rounded-xl shadow ${canUndo ? themeClasses.btn : "bg-gray-300 text-gray-600"}`} onClick={doUndo}>Undo (U)</button>
                <button className={`px-3 py-2 rounded-xl shadow ${themeClasses.btn}`} onClick={() => setTheme((th) => (th === "emerald" ? "rose" : th === "rose" ? "sky" : "emerald"))}>Switch Theme (T)</button>
                <button className={`px-3 py-2 rounded-xl shadow ${soundOn ? themeClasses.btn : "bg-gray-300 text-gray-600"}`} onClick={() => setSoundOn((s) => !s)}>{soundOn ? "Sound: On" : "Sound: Off"}</button>
              </div>
            </header>

            <section className={`mt-3 p-3 rounded-xl border border-black/5 ${themeClasses.panel}`}>
              <div className="flex flex-wrap items-center gap-4 text-sm">
                <div><span className="font-semibold">Time:</span> {fmtTime(elapsed)}</div>
                <div><span className="font-semibold">Moves:</span> {moves}</div>
                <div><span className="font-semibold">Pairs left:</span> {remainingPairs}</div>
                <div className="grow" />
                <div className="italic opacity-80">{gameWon ? "You cleared the board! Press New Game to play again." : message}</div>
              </div>
            </section>

            <div ref={containerRef} className="relative mt-4 h-[68vh] min-h-[520px] rounded-2xl border border-black/5 overflow-hidden bg-white">
              <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-white to-slate-100" />
              {tiles.map((t) => (<Tile key={t.id} t={t} />))}
              <AnimatePresence>
                {gameWon && (
                  <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className="absolute inset-0 flex items-center justify-center">
                    <div className="px-6 py-4 rounded-2xl bg-white/80 backdrop-blur shadow-2xl border border-black/5 text-center">
                      <div className="text-3xl font-bold mb-2">ðŸŽ‰ Victory!</div>
                      <div className="text-sm opacity-80 mb-3">Press <b>New Game</b> to play again.</div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>

            <footer className="mt-4 text-xs opacity-70 flex items-center gap-2">
              <span>Shortcuts: H=Hint, U=Undo, S=Shuffle, R=Restart, T=Theme.</span>
              <span>Free tile rule: no tile on top and at least one side free.</span>
            </footer>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<MahjongSolitaire />);
  </script>
</body>
</html>
